<!DOCTYPE html>
<html lang="ko">

<head>
  <meta charset="UTF-8" />
  <meta name="author" content="루미나, 신미현, 이승민, 조현성, 한시은, 이채연" />
  <meta name="description" content="MBC 아카데미 생성형 AI를 활용한 영상 웹퍼블리셔&프론트엔드(React) 개발자 양성 (KDT) 2차 팀 프로젝트 포트폴리오 작품입니다." />
  <meta name="keyword" content="자살방지, 루미나" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Lumina</title>
  <link rel="stylesheet" href="./css/reset.css" />
  <link rel="stylesheet" href="./css/main/style.css" />
  <link rel="stylesheet" href="./css/main/media.css" />
  <link rel="stylesheet" href="./css/main/banner_media.css" />
</head>

<body>
  <header id="header">
    <header class="header">
      <h1 class="logo"><a href="index.html">LUMINA</a></h1>
      <button id="openModalBtn">로그인 / 회원가입</button>

      <div id="modal" class="modal hidden">
        <div class="modal-content">
          <span id="closeModalBtn" class="close">&times;</span>
          <h2>로그인</h2>
          <form>
            <div>
              <label for="email">이메일</label>
              <input type="email" id="email" required />
            </div>
            <div class="password-row">
              <label for="password">비밀번호</label>
              <input type="password" id="password" required />
            </div>
            <button type="submit">로그인</button>
          </form>
          <ul>
            <li>
              <a href="javascript:;">회원가입</a>
            </li>
            <li>
              <a href="javascript:;">아이디 찾기</a>
            </li>
            <li>
              <a href="javascript:;">비밀번호 찾기</a>
            </li>
          </ul>
        </div>
      </div>
      <div id="barMenu">
        <div class="bar"></div>
      </div>
      <nav class="nav">
        <ul>
          <li><a href="./sub3.html">정보 & 자료실</a>
            <ul class="submenu">
              <li><a href="./sub3.html">정보 & 자료실</a></li>
              <li><a href="./sub3.html">자가관리 가이드</a></li>
              <li><a href="./sub3.html">전문기관 링크</a></li>
            </ul>
          </li>
          <li><a href="./sub2.html">우울 척도검사</a>
            <ul class="submenu">
              <li><a href="./sub2.html">우울 척도검사</a></li>
              <li><a href="./sub2.html">상세 우울검사</a></li>
              <li><a href="./sub2.html">검사 해석 가이드</a></li>
              <li><a href="./sub2.html">결과 기반 도움찾기</a></li>
            </ul>
          </li>
          <li><a href="./sub1.html">사연작성</a>
            <ul class="submenu">
              <li><a href="./sub1.html">사연작성</a></li>
              <li><a href="./sub1.html">사연 모아보기</a></li>
              <li><a href="./sub1.html">전문가의 답장</a></li>
              <li><a href="./sub1.html">응원 메시지 남기기</a></li>
            </ul>
          </li>
          <li><a href="./sub4.html">커뮤니티 & 참여</a>
            <ul class="submenu">
              <li><a href="./sub4.html">온라인 교육 과정</a></li>
              <li><a href="./sub4.html">FAQ</a></li>
              <li><a href="./sub4.html">홍보 자료실</a></li>
            </ul>
          </li>
        </ul>
      </nav>
      <div class="overlay"></div>
    </header>
  </header>

  <section id="banner">
    <div class="banner">
      <div class="stage" id="stage">
        <ul class="spots">
          <!-- 애니메이션 대상에 공통 클래스 'anim' 부여 -->
          <!-- <li class="anim">...</li> 등 -->
        </ul>

        <div class="final-banner" id="finalBanner" aria-live="polite">
          <span class="final-text goun anim" id="finalText"></span>
        </div>
      </div>

      <div class="controls">
        <button class="btn" id="playBtn">▶</button>
        <button class="btn" id="pauseBtn">&#8214;</button>
        <button class="btn" id="replayBtn">&#8634;</button>
      </div>
    </div>
  </section>

  <section id="content2">
    <div class="container">
      <section class="contents2">
        <div class="chart_box">
          <h2>국내 연간 자살률</h2>
          <canvas id="suicideChart"></canvas>
        </div>

        <div class="accordion">
          <div class="accordion_item">
            <button class="accordion_header">
              1. 지금 당장 도움이 필요할 때
              <i class="fa-solid fa-square-caret-down"></i>
            </button>

            <div class="accordion_content">
              <p>
                위험하다고 느껴진다면 혼자 버티지 말고 119 또는 자살예방상담
                1393으로 바로 연락하세요.
              </p>
            </div>
          </div>

          <div class="accordion_item">
            <button class="accordion_header">
              2. 내 마음을 표현해보세요
              <i class="fa-solid fa-square-caret-down"></i>
            </button>
            <div class="accordion_content">
              <p>
                “지금 너무 지쳐요” 한마디만으로도 누군가와 연결될 수 있습니다.
              </p>
            </div>
          </div>

          <div class="accordion_item">
            <button class="accordion_header">
              3. 지금 바로 할 수 있는 작은 방법
              <i class="fa-solid fa-square-caret-down"></i>
            </button>
            <div class="accordion_content">
              <p>
                심호흡, 바람 쐬기, 신뢰하는 사람에게 메시지 보내기 같은 작은
                행동이 도움이 됩니다.
              </p>
            </div>
          </div>

          <div class="accordion_item">
            <button class="accordion_header">
              4. 함께할 수 있는 사람들
              <i class="fa-solid fa-square-caret-down"></i>
            </button>
            <div class="accordion_content">
              <p>
                당신의 이야기를 들어주고 싶어 하는 사람이 반드시 있습니다.
              </p>
            </div>
          </div>

          <div class="accordion_item">
            <button class="accordion_header">
              5. 희망은 다시 찾아옵니다
              <i class="fa-solid fa-square-caret-down"></i>
            </button>
            <div class="accordion_content">
              <p>
                지금의 어둠도 지나갑니다. 삶은 다시 당신을 기다리고 있습니다.
              </p>
            </div>
          </div>
        </div>
      </section>
    </div>
    <!-- //.container -->
  </section>

  <section id="content1">
    <div class="container">
      <section class="content1">
        <h2 class="cont1_tit">긴급상담 &#183; 지원안내</h2>
        <div class="wrap">
          <div class="cont1_left">
            <a href="javascript:;"></a>
          </div>
          <div class="cont1_rigth goun">
            <p>자살예방상담전화 1393 (24시간, 무료)</p>
            <p>생명의 전화 1588-9191</p>
            <p>보건복지상담센터 129</p>
            <p>청소년 전화 1388 (24시간, 무료)</p>
            <p>한국심리상담전화 1566-2525</p>
            <p>정신건강상담전화 1577-0199</p>
            <p>아동학대 신고 112</p>
            <p>한국생명존중희망재단 상담 02-2203-0053</p>
          </div>
        </div>
      </section>
    </div><!-- //.container -->
  </section>


  <section id="content3">
    <div class="container">
      <section class="content3">

        <h1 class="title">희망으로 가는 길 <br>
          <span class="sub_text">핀 버튼을 눌러보세요</span>
        </h1>

        <main class="wrap" aria-label="희망으로 가는 길">
          <svg class="road-svg" viewBox="0 0 1280 1500" width="1280" height="1100" role="img"
            shape-rendering="geometricPrecision">

            <defs>
              <linearGradient id="asphalt" x1="0" y1="0" x2="0" y2="1">
                <stop offset="0%" stop-color="#1e2531" />
                <stop offset="100%" stop-color="#1a212d" />
              </linearGradient>
            </defs>

            <!-- scene 이동/회전 -->
            <g id="scene" transform="translate(20,0) rotate(-5 640 750)">
              <g id="roadGroup">
                <path id="roadBase" class="road-base" />
                <path id="roadCenter" class="road-center dash" />
                <g id="roadGlow"></g>
              </g>

              <!-- 핀 -->
              <g id="pins">
                <g class="pin" data-progress="0.18" data-text='["숨 고르기","작은 걸음도 충분해요","괜찮아, 잘하고 있어요"]'>
                  <circle cx="32" cy="2" r="21" fill="#cc0d10"></circle>
                  <rect x="30.2" y="23" width="5" height="70" rx="1.2" fill="#7d0a0c"></rect>
                </g>
                <g class="pin" data-progress="0.52" data-text='["도움은 가까이에","항상 당신의 소리를 경청할게요","응원하고 있어요"]'>
                  <circle cx="32" cy="2" r="21" fill="#cc0d10"></circle>
                  <rect x="30.2" y="23" width="5" height="70" rx="1.5" fill="#7d0a0c"></rect>
                </g>
                <g class="pin" data-progress="0.85" data-text='["거의 다 왔어요","빛은 가까워져요","함께 걸어요"]'>

                  <!-- 핀볼 -->
                  <circle cx="32" cy="-120" r="21" fill="#cc0d10"></circle>

                  <!-- 핀셋 -->
                  <rect x="30" y="-100" width="5" height="70" rx="1.2" fill="#7d0a0c"></rect>
                </g>
              </g>
            </g>
          </svg>

          <!-- 말풍선 -->
          <div class="bubble" id="bubble" role="status" aria-live="polite">
            <div class="bubble-arrow"></div>
            <p id="bubbleText"></p>
          </div>
        </main>
        <a href="#" class="secBtn">&#8679;</a>
      </section>
    </div>

    <!-- //.container -->
  </section>


  <footer id="footer">
    <div class="container">
      <footer class="footer">
        <div class="f_logo">
          <a href="./index.html"><img src="./main_img/image 1.png" alt="푸터 로고 이미지"></a>
        </div>
        <div class="f_copy">
          Copyright &copy; 2025 Lumina. All rights reserved.<br>
          <span>
            당신의 삶은 소중합니다.<br>
            본 사이트는 개인용 포트폴리오 작품으로, 상업적 용도로 절대 사용되지 않습니다.<br>
            이미지 출처 : LottieFiles, 대덕구정신건강복지센터, 보건복지부, 1393, 한국생명의전화
          </span>
        </div>
      </footer>
    </div><!-- //.container -->
  </footer>

  <!-- 제이쿼리 연결 -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>


  <!-- 차트js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="./js/contents2.js"></script>




  <!-- 로띠에 연결 -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lottie-web/5.12.2/lottie.min.js"></script>
  <script src="./js/bannerScript.js"></script>

  <script src="./js/all.js"></script>



  <!-- 헤더 -->
  <script>
    //헤더

    // 헤더 로그인 버튼 눌렀을 때 모듈창
    const $modal = $("#modal");
    const $openModalBtn = $("#openModalBtn");
    const $closeModalBtn = $("#closeModalBtn");

    $openModalBtn.on("click", function () {
      $modal.removeClass("hidden");
    });

    $closeModalBtn.on("click", function () {
      $modal.addClass("hidden");
    });

    $(window).on("click", function (e) {
      if (e.target === $modal[0]) {
        $modal.addClass("hidden");
      }
    });

    //햄버거 메뉴를 클릭했을 때 나왔다가 들어가는 이벤트
    $("#barMenu").click(function () {
      $(".nav .submenu").hide(); // 초기화
      $(".header .nav").toggleClass("open");

      if ($(".header .nav").hasClass("open")) {
        $("body").css("overflow", "hidden");
        $(".overlay").fadeIn();
      } else {
        $("body").css("overflow", "auto");
        $(".overlay").fadeOut();
      }
    });

    // 서브메뉴가 있는 li 클릭 시 서브메뉴 토글
    $(".nav > ul > li > a").click(function (e) {
      e.preventDefault(); // 링크 이동 막기 (필요시)
      const submenu = $(this).siblings(".submenu");
      if (submenu.is(":visible")) {
        submenu.slideUp();
      } else {
        $(".nav .submenu").slideUp(); // 다른 서브메뉴 닫기
        submenu.slideDown();
      }
    });




    document.addEventListener('DOMContentLoaded', () => {

      const el = document.querySelector('.cont1_left '); // 넣을 박스
      lottie.loadAnimation({
        container: el,
        renderer: 'svg',
        loop: true,
        autoplay: true,
        path: './json/Sos.json'   // ← 필요시 /json/ 또는 ../json/ 로 조정
      });
    });
  </script>

  <!-- 콘텐츠3 -->
  <script>
    /* ======================================================================
     * 🛣️ 인터랙티브 도로 스크립트 — 최종 주석 버전
     * 이 코드는 SVG로 구불구불한 도로를 생성하고, data-progress 비율에 따라 핀을 도로 위에 배치합니다.
     * 핀을 클릭하면 해당 도로 구간만 빛나며, 핀 옆에 말풍선을 띄워 순환 텍스트를 보여줍니다.
     * 문서 빈 곳을 클릭하면 효과가 모두 초기화됩니다.
     * 하단의 .secBtn(Top 버튼)을 누르면 부드럽게 페이지 상단으로 이동합니다. (jQuery 필요)
     *
     * [필요한 HTML 구조]
     *  - <svg> 내부에 #roadGroup(<g>) / #roadGlow(<g>)가 있어야 합니다.
     *  - 핀: <g class="pin" data-progress="0.25" data-text='["문장1","문장2"]'> … </g>
     *  - 말풍선: <div id="bubble"><span id="bubbleText"></span></div>
     *  - Top 버튼: <a href="#" class="secBtn">Top</a>
     * ====================================================================== */

    // ── SVG 및 UI 요소 참조(없으면 null 반환) ───────────────────────────────────
    const roadGroup = document.getElementById('roadGroup');   // 도로 전체 그룹(<g>)
    const glowG = document.getElementById('roadGlow');        // 빛나는 도로 효과 레이어(<g>)
    const base0 = document.getElementById('roadBase');        // (초기 템플릿) 도로 베이스 path
    const center0 = document.getElementById('roadCenter');    // (초기 템플릿) 도로 중앙선 path
    const pins = document.querySelectorAll('g.pin');          // 도로 위 핀들(<g class="pin">)
    const bubble = document.getElementById('bubble');         // 말풍선 컨테이너(HTML)
    const bubbleText = document.getElementById('bubbleText'); // 말풍선 텍스트 노드

    /* 파라미터 (도로 모양/두께/컷팅 등) */
    const X = 640, startY = 24;         // 도로 시작 좌표(가로 중심축 X, 시작 Y)
    const GAP = 0, GAP_HALF = GAP / 2;  // 세그먼트 양끝 트리밍 거리(현재 0)
    const K1 = 0.35, K2 = 0.65;         // 제어점 배치 비율(세그먼트 세로 step에 곱)
    const ROAD_W = 70;                  // 도로 두께(px)

    const BG_COLOR = '#ffffff';         // 컷팅 라인 색(배경과 동일해야 자연스러움)
    const CUT_HALF_LEN = 120;           // 컷팅 라인 반쪽 길이(전체는 2배)
    const CUT_EXTRA = 4;                // 컷팅 라인 두께 여유분(도로폭 + 여유로 깔끔 절단)

    // bends: 세그먼트별 "얼마나 휘고(step), 어느 쪽으로(dir), 얼마나 크게(amp)"
    // dir: 'R' → 오른쪽으로 휘어짐 / 'L' → 왼쪽으로 휘어짐
    const bends = [
      { dir: 'R', amp: 220, step: 260 },
      { dir: 'L', amp: 120, step: 210 },
      { dir: 'R', amp: 280, step: 290 },
      { dir: 'L', amp: 340, step: 330 },
      { dir: 'R', amp: 160, step: 250 },
      { dir: 'L', amp: 240, step: 360 },
    ];

    // ── 보조 수학 함수들 ───────────────────────────────────────────────────────
    // lerp: 선형 보간 (a~b 사이를 t(0~1) 비율로 연결)
    const lerp = (a, b, t) => a + (b - a) * t;

    // 베지어 곡선(p0,c1,c2,p3)에서 t(0~1)에 해당하는 한 점 좌표 계산
    function pointOnCubic(p0, c1, c2, p3, t) {
      const x1 = lerp(p0.x, c1.x, t), y1 = lerp(p0.y, c1.y, t);
      const x2 = lerp(c1.x, c2.x, t), y2 = lerp(c1.y, c2.y, t);
      const x3 = lerp(c2.x, p3.x, t), y3 = lerp(c2.y, p3.y, t);
      const xa = lerp(x1, x2, t), ya = lerp(y1, y2, t);
      const xb = lerp(x2, x3, t), yb = lerp(y2, y3, t);
      return { x: lerp(xa, xb, t), y: lerp(ya, yb, t) };
    }

    // tangentAt: 곡선의 접선(방향) 단위벡터 근사
    //  - t 주변의 아주 가까운 두 점 a/b를 구해 (b - a)를 정규화하여 방향을 얻음
    function tangentAt(p0, c1, c2, p3, t) {
      const eps = 0.002; // 근사 미분 간격
      const t0 = Math.max(0, Math.min(1, t - eps));
      const t1 = Math.max(0, Math.min(1, t + eps));
      const a = pointOnCubic(p0, c1, c2, p3, t0);
      const b = pointOnCubic(p0, c1, c2, p3, t1);
      let tx = b.x - a.x, ty = b.y - a.y;
      const len = Math.hypot(tx, ty) || 1; // 0 나눗셈 방지
      return { tx: tx / len, ty: ty / len };
    }

    // move: 점 p를 (vx,vy) 방향으로 거리 d만큼 이동한 새 점 반환
    const move = (p, vx, vy, d) => ({ x: p.x + vx * d, y: p.y + vy * d });

    // addCutLine: 세그먼트 시작/끝에 배경색 굵은 선을 그려 "도로가 잘린 느낌" 연출
    //  - (nx,ny)는 접선의 법선 방향(접선(tx,ty)에 대해 (-ty,tx))
    function addCutLine(parent, x, y, nx, ny) {
      const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
      line.setAttribute('x1', x - nx * CUT_HALF_LEN);
      line.setAttribute('y1', y - ny * CUT_HALF_LEN);
      line.setAttribute('x2', x + nx * CUT_HALF_LEN);
      line.setAttribute('y2', y + ny * CUT_HALF_LEN);
      line.setAttribute('stroke', BG_COLOR);
      line.setAttribute('stroke-width', ROAD_W + CUT_EXTRA);
      line.setAttribute('stroke-linecap', 'butt');
      parent.appendChild(line);
    }

    /* ── 1) 곡선 세그먼트 정의: bends를 순회하며 p0,c1,c2,p3를 계산 ───────────── */
    const segDefs = [];
    let y = startY, prevC2 = null; // 현재 시작 y와, 이전 세그먼트의 c2(연결용)

    for (let i = 0; i < bends.length; i++) {
      const b = bends[i];
      const dir = b.dir === 'R' ? 1 : -1;         // 오른쪽(+1) / 왼쪽(-1)

      // 세그먼트 수직 진행(step)을 비율(K1,K2)로 쪼개 제어점 y 배치
      const y1 = y + b.step * K1;
      const y2 = y + b.step * K2;
      const y3 = y + b.step;                      // 끝점 y

      const ax = X + dir * b.amp;                 // 좌우 휘어지는 진폭만큼 x 이동

      const p0 = { x: X, y: y };                // 시작점
      const c2 = { x: ax, y: y2 };                // 제어점2
      let c1;                                     // 제어점1

      if (prevC2) {
        // 이전 세그먼트 c2 기준으로 X축 중심(X) 대칭 배치 → 연결 곡선이 자연스러움
        c1 = { x: (2 * X - prevC2.x), y: (2 * y - prevC2.y) };
        // 너무 위/아래로 과하게 튀지 않도록 y 범위 제한
        c1.y = Math.min(Math.max(c1.y, y + 10), y1);
      } else {
        // 첫 세그먼트는 단순 배치
        c1 = { x: ax, y: y1 };
      }

      const p3 = { x: X, y: y3 };                // 끝점

      segDefs.push({ p0, c1, c2, p3 });           // 저장
      prevC2 = c2;                                 // 다음 세그먼트 대비
      y = y3;                                      // 다음 세그먼트 시작 y 갱신
    }

    /* ── 2) 트리밍: 세그먼트 양 끝을 GAP_HALF만큼 접선 방향으로 미세 조정 ─────── */
    const trimmed = segDefs.map(def => {
      const { p0, c1, c2, p3 } = def;
      const tS = tangentAt(p0, c1, c2, p3, 0);   // 시작 접선
      const tE = tangentAt(p0, c1, c2, p3, 1);   // 끝 접선
      const p0t = move(p0, tS.tx, tS.ty, GAP_HALF);
      const c1t = move(c1, tS.tx, tS.ty, GAP_HALF);
      const p3t = move(p3, tE.tx, tE.ty, -GAP_HALF);
      const c2t = move(c2, tE.tx, tE.ty, -GAP_HALF);
      return { p0: p0t, c1: c1t, c2: c2t, p3: p3t };
    });

    /* ── 3) 기존 템플릿 정리 & SVG path 재생성 (base/center/glow) ─────────────── */
    if (base0) base0.remove();            // 초기 베이스 제거(있으면)
    if (center0) center0.remove();        // 초기 중앙선 제거(있으면)
    glowG.innerHTML = '';                 // glow 레이어 초기화
    // 이전 렌더 잔여물 제거
    [...roadGroup.querySelectorAll('.road-base, .road-center')].forEach(n => n.remove());

    // 컷팅 라인 그룹 준비(없으면 생성)
    let cutsG = document.getElementById('roadCuts');
    if (!cutsG) {
      cutsG = document.createElementNS("http://www.w3.org/2000/svg", "g");
      cutsG.setAttribute('id', 'roadCuts');
      roadGroup.appendChild(cutsG);
    } else cutsG.innerHTML = '';

    const basePaths = [];   // 도로 바탕 path 목록
    const centerPaths = []; // 도로 중앙선 path 목록

    // 각 세그먼트에 대해 동일한 d로 base/center/glow를 순서대로 생성
    trimmed.forEach(seg => {
      const { p0, c1, c2, p3 } = seg;
      const dSeg = `M ${p0.x} ${p0.y} C ${c1.x} ${c1.y}, ${c2.x} ${c2.y}, ${p3.x} ${p3.y}`;

      // 1) 바탕 도로
      const basePath = document.createElementNS("http://www.w3.org/2000/svg", "path");
      basePath.setAttribute("d", dSeg);
      basePath.setAttribute("class", "road-base");
      roadGroup.insertBefore(basePath, cutsG); // 컷팅 라인보다 뒤에 깔기
      basePaths.push(basePath);

      // 2) 중앙선(점선은 CSS에서 .dash 또는 .road-center에 stroke-dasharray 지정)
      const centerPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
      centerPath.setAttribute("d", dSeg);
      centerPath.setAttribute("class", "road-center dash");
      roadGroup.insertBefore(centerPath, cutsG);
      centerPaths.push(centerPath);

      // 3) 빛 효과 path (클릭 시 .active로 발광 스타일 적용)
      const glowPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
      glowPath.setAttribute("d", dSeg);
      glowPath.setAttribute("class", "road-glow");
      roadGroup.insertBefore(glowPath, cutsG);
    });

    // 각 세그먼트 시작/끝 지점에 컷팅 라인 추가 (배경으로 굵게 가로질러 잘린 느낌)
    trimmed.forEach(seg => {
      const { p0, c1, c2, p3 } = seg;
      const tS = tangentAt(p0, c1, c2, p3, 0); // 시작 접선 → 법선(-ty, tx)
      addCutLine(cutsG, p0.x, p0.y, -tS.ty, tS.tx);
      const tE = tangentAt(p0, c1, c2, p3, 1); // 끝 접선 → 법선(-ty, tx)
      addCutLine(cutsG, p3.x, p3.y, -tE.ty, tE.tx);
    });

    /* ── 4) 세그먼트 길이/인덱스 테이블 ─────────────────────────────────────── */
    //  - 각 path.getTotalLength()로 세그먼트 길이를 구하고 누적합 segCum을 만들면
    //    "전체 길이 L이 어느 세그먼트에 속하는가"를 빠르게 판정 가능
    let totalLen = 0, segCum = [];
    function rebuildSegIndex() {
      const lens = basePaths.map(p => p.getTotalLength());
      segCum = [0];
      lens.forEach(len => segCum.push(segCum[segCum.length - 1] + len));
      totalLen = segCum[segCum.length - 1];
    }
    rebuildSegIndex();

    /* ── 5) 핀 위치+세그먼트 기록 ──────────────────────────────────────────── */
    function placePins() {
      // 뷰박스/스케일 변동에 대비해 길이/누적합 갱신(안전)
      rebuildSegIndex();

      pins.forEach(pin => {
        // data-progress(0~1)를 안전하게 보정
        const t = Math.max(0, Math.min(1, parseFloat(pin.dataset.progress) || 0));
        const L = t * totalLen; // 전체 길이 상의 목표 거리

        // L이 속한 세그먼트 idx 탐색 (없으면 마지막 바로 전 인덱스로 보정)
        let idx = segCum.findIndex((v, i) => L < segCum[i + 1]);
        if (idx === -1) idx = segCum.length - 2;

        const local = L - segCum[idx]; // 해당 세그먼트 내부 거리
        const pt = basePaths[idx].getPointAtLength(local); // 실제 좌표

        pin.setAttribute('transform', `translate(${pt.x}, ${pt.y})`); // SVG 이동
        pin.dataset.seg = String(idx); // 클릭 시 빠르게 접근하기 위해 idx 저장
      });
    }
    placePins();

    // 창 크기 변경 시(반응형) 핀 위치 재계산
    window.addEventListener('resize', placePins);

    /* ── 6) 클릭: 해당 세그먼트만 활성화(Glow/라인 하이라이트) + 말풍선 ───────── */
    pins.forEach(pin => {
      pin.addEventListener('click', e => {
        e.stopPropagation(); // 문서 클릭 초기화와 충돌 방지

        // data.seg이 없으면 progress로 계산해 보정
        let idx = parseInt(pin.dataset.seg, 10);
        if (Number.isNaN(idx)) {
          const t = parseFloat(pin.dataset.progress) || 0;
          const L = Math.max(0, Math.min(1, t)) * totalLen;
          idx = segCum.findIndex((v, i) => L < segCum[i + 1]);
          if (idx === -1) idx = segCum.length - 2;
          pin.dataset.seg = String(idx);
        }

        // glow 레이어: 해당 idx만 .active (CSS에서 발광/강조)
        [...glowG.children].forEach((seg, i) => seg.classList.toggle('active', i === idx));
        // 도로(base/center)도 동일 idx만 .lit (CSS에서 굵기/색/광택 등)
        basePaths.forEach((p, i) => p.classList.toggle('lit', i === idx));
        centerPaths.forEach((p, i) => p.classList.toggle('lit', i === idx));

        // 말풍선 텍스트: data-text가 '["a","b"]' 형태라면 순환 출력
        const list = JSON.parse(pin.dataset.text || '[]');
        if (!pin._i) pin._i = 0; // 핀별 순환 인덱스 저장(첫 클릭 시 0)

        bubbleText.textContent = list.length ? list[pin._i] : '';
        pin._i = list.length ? (pin._i + 1) % list.length : 0;

        // 말풍선 위치: SVG CTM(현재 변환 행렬)의 translate 성분(e,f) 근처에 띄움
        const m = pin.getCTM();
        bubble.style.left = `${m.e + 20}px`; // 핀 우측으로 20px
        bubble.style.top = `${m.f - 8}px`;  // 핀 약간 위로 8px
        bubble.classList.add('show');        // CSS .show로 표시(transition 등)
      });
    });

    /* ── 7) 문서 클릭 시(빈 공간) 초기화: 말풍선 숨김 + 모든 강조 해제 ─────────── */
    document.addEventListener('click', () => {
      bubble.classList.remove('show'); // 말풍선 닫기
      // 모든 glow 비활성화
      [...glowG.children].forEach(seg => seg.classList.remove('active'));
      // 모든 .lit 제거
      roadGroup.querySelectorAll('.road-base.lit, .road-center.lit').forEach(n => n.classList.remove('lit'));
    });

    /* ── 8) Top 버튼: 최상단으로 부드럽게 스크롤 (jQuery 필요) ──────────────── */
    //  - .secBtn을 클릭하면 a태그 기본 이동을 막고, 문서 스크롤을 0까지 600ms로 애니메이션
    $(".secBtn").click(function (e) {
      e.preventDefault();                         // 링크 이동 방지
      $("html,body").animate({ scrollTop: 0 }, 600); // 0.6초 동안 최상단으로 이동
    });
  </script>


</body>

</html>